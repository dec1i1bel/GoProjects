package main

import "fmt"

type aStructure struct {
	field1 complex128
	field2 int
}

// функция получает в качестве параметра указатель на переменную. тогда все изменения параметра внутри функции являются постоянными, то есть отражаются в переметре и за пределами функции. и тогда нет необходимости что-то возвращать.
func processPointer(x *float64) {
	*x = *x * *x
}

// ф-я прин-ет парам-м обычную перем-ую, а возвр-ет указатель на переменную, в которой хран-ся знач-е типа float64
func returnPointer(x float64) *float64 {
	temp := 2 * x
	return &temp
}

// ф-я прин-ет указатель на переменную типа float64 в качестве входных данных и возвращает указатель на перем-ую типа float64 в качестве выходных. Нотация *x используется для получения значения, хранящегося по адресу в памяти, который хранится в x.
func bothPointers(x *float64) *float64 {
	temp := 2 * *x
	return &temp
}

func main() {
	var f float64 = 12.123
	fmt.Println("1_memory address of f:", &f) // адрес перем-ой в памяти

	// указатель на f
	// fP теперь является указателем на адрес в памяти переменной f. Любые изменения значения, хранящегося в адресе памяти fP, также влияют на значение f...
	fp := &f
	fmt.Println("2_memory address of f:", fp)
	fmt.Println("3_value of f:", *fp) // разыменование
	// значение f меняется
	processPointer(fp)
	fmt.Printf("4_value of f: %2f\n", f)
	// ... но это верно только до тех пор, пока fP указывает на адрес в памяти переменной f

	// Значение f не изменяется, поскольку функция использует только ее значение
	x := returnPointer(f)
	fmt.Printf("5_value of x: %2f\n", *x)

	// значение f, а также значение, сохраненное в адресе памяти fP, не изменяется, поскольку функция bothPointers() не вносит никаких изменений в значение, сохраненное в адресе памяти fP
	xx := bothPointers(fp)
	fmt.Printf("value of xx: %2f\n", *xx)

	// Переменная k — это указатель на структуру aStructure. Поскольку k указывает в никуда, Go заставляет его указывать на nil, что является нулевым значением для указателей
	var k *aStructure
	fmt.Println(k)
	if k == nil {
		k = new(aStructure) // k больше не nil, но оба знач-я струк-ры содержат нулевые значения своих типов
	}
	fmt.Printf("%+v\n", k)
	if k != nil {
		fmt.Println("k is not nil")
	}
}
